
#include "Engine/System/Thread/Thread.hpp"



// CONSTRUCTOR
Thread::Thread()
{

}

// DESTRUCTOR
Thread::~Thread()
{

}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ThreadHandle Thread::ThreadCreate(char const *name, size_t stack_size, threadEntryCB entry, void *arg)
{
	StartThreadArgs_t *args = new StartThreadArgs_t();
	args->m_name     = name;
	args->m_function = entry;
	args->m_arg      = arg;

	// Default to 1 KB stack size
	/*if (stack_size == 0) {
		stack_size = DEFAULT_THREAD_STACK_SIZE;
	}*/

	DWORD id = 0;
	ThreadHandle handle = ::CreateThread(NULL, stack_size, ThreadEntryPoint, args, 0, &id);

	// Return the handle
	return handle;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ThreadHandle Thread::ThreadCreate(threadEntryCB entry, void *userData /*= nullptr*/)
{
	return ThreadCreate( nullptr, 0, entry, userData );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ThreadHandle Thread::ThreadCreate(char const *name, threadEntryCB entry, void *arg)
{
	return ThreadCreate( name, 0, entry, arg );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadJoin(ThreadHandle* threadHandle,size_t const count)
{
	for (size_t i = 0; i < count; ++i) 
	{
		ThreadJoin(threadHandle[i]);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadJoin(ThreadHandle threadHandle)
{
	//if (INVALID_THREAD_HANDLE != threadHandle) 
	{
		::WaitForSingleObject(threadHandle, INFINITE);
		::CloseHandle(threadHandle);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadDetach(ThreadHandle threadHandle)
{
	//if (INVALID_THREAD_HANDLE != threadHandle)
	{
		::CloseHandle(threadHandle);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadCreateAndDetach(char const *name,size_t const stack_size,threadEntryCB entry, void *arg)
{
	ThreadHandle threadHandle = ThreadCreate(name, stack_size, entry, arg);
	ThreadDetach(threadHandle);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadCreateAndDetach(char const *name, threadEntryCB entry, void *arg)
{
	ThreadHandle threadHandle = ThreadCreate(name, entry, arg);
	ThreadDetach(threadHandle);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadYield()
{
	::SwitchToThread();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadSleep(int ms)
{
	::Sleep( (DWORD) ms );
}
