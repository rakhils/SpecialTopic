#include "Engine/System/Thread/Thread.hpp"
#include "Engine/Math/MathUtil.hpp"
#include "Engine/FileUtil/File.h"
#include "Engine/Logger/LogManager.hpp"
std::string Thread::bigTest;

// CONSTRUCTOR
Thread::Thread()
{

}

// DESTRUCTOR
Thread::~Thread()
{

}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ThreadHandle Thread::ThreadCreate(char const *name, size_t stack_size, threadEntryCB entry, void *arg)
{
	StartThreadArgs_t *args = new StartThreadArgs_t();
	args->m_name     = name;
	args->m_function = entry;
	args->m_arg      = arg;

	// Default to 1 KB stack size
	/*if (stack_size == 0) {
		stack_size = DEFAULT_THREAD_STACK_SIZE;
	}*/

	DWORD id = 0;
	ThreadHandle handle = ::CreateThread(NULL, stack_size, ThreadEntryPoint, args, 0, &id);

	// Return the handle
	return handle;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ThreadHandle Thread::ThreadCreate(threadEntryCB entry, void *userData /*= nullptr*/)
{
	return ThreadCreate( nullptr, 0, entry, userData );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ThreadHandle Thread::ThreadCreate(char const *name, threadEntryCB entry, void *arg)
{
	return ThreadCreate( name, 0, entry, arg );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadJoin(ThreadHandle* threadHandle,size_t const count)
{
	for (size_t i = 0; i < count; ++i) 
	{
		ThreadJoin(threadHandle[i]);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadJoin(ThreadHandle threadHandle)
{
	//if (INVALID_THREAD_HANDLE != threadHandle) 
	{
		::WaitForSingleObject(threadHandle, INFINITE);
		::CloseHandle(threadHandle);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadDetach(ThreadHandle threadHandle)
{
	//if (INVALID_THREAD_HANDLE != threadHandle)
	{
		::CloseHandle(threadHandle);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadCreateAndDetach(char const *name,size_t const stack_size,threadEntryCB entry, void *arg)
{
	ThreadHandle threadHandle = ThreadCreate(name, stack_size, entry, arg);
	ThreadDetach(threadHandle);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadCreateAndDetach(char const *name, threadEntryCB entry, void *arg)
{
	ThreadHandle threadHandle = ThreadCreate(name, entry, arg);
	ThreadDetach(threadHandle);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadYield()
{
	::SwitchToThread();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/08
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::ThreadSleep(int ms)
{
	::Sleep( (DWORD) ms );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/10
*@purpose : Test on threads
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::TestOnThread(int numofThreads)
{
	FILE *file = FileOpenForWrite("Garbage.txt");
	for(int threadIndex = 0;threadIndex < numofThreads;threadIndex++)
	{
		ThreadCreateAndDetach("TestThread", TestWriteToFile, file);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/10
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::TestOnMainThread()
{
	FILE *fp = FileOpenForAppend("garbage.txt");
	TestWriteToFile(fp);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/10
*@purpose : 
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::TestWriteToFile(void *data)
{ 
	FILE *file = (FILE*)data;
	for (int charIndex = 0; charIndex < 12000000; charIndex++) 
	{
		char ch = GetRandomCharacter();
		FileAppendChar(file, ch);
	}
	FileClose(file);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/17
*@purpose : Test log's read and write
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::TestLogReadWrite(char const *srcFile, int threadCount)
{
	bigTest = std::string(srcFile);
	for (int threadIndex = 0; threadIndex < threadCount; threadIndex++)
	{
		ThreadCreateAndDetach("TestThread", TestLogRead, &threadIndex);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*DATE    : 2018/07/17
*@purpose : NIL
*@param   : NIL
*@return  : NIL
*///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Thread::TestLogRead(void *data)
{
	int *threadCount = (int*)(void*)&data;
	int	 count		 = *threadCount;
	//int threadC     = *(int*)data;
	char *ch     = (char*)FileReadToBuffer(bigTest.c_str());
	char *chcopy = ch;
	int lineCount    = 0;
	int index = 0;
	while(*ch != NULL)
	{
		index  = 0;
		chcopy = ch;
		while(*ch != '\n' && *ch != NULL) // && index < 200)
		{
			ch++;
			index++;
		}
		lineCount++;
		if(*ch == '\n')
		{
			ch++;
		}
		if(index == 0 || index == 1)
		{
			std::string onestring = "";
			LogManager::GetInstance()->LogPrintf(true,"[ %i : %i ] %s\n", count, lineCount, onestring.c_str());
			continue;
		}
		std::string onestring(chcopy, index );
		LogManager::GetInstance()->LogPrintf( true,"[ %i : %i ] %s\n", count, lineCount, onestring.c_str()); 
	}
}
